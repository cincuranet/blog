---
title: "How to map your custom objects in Entity Framework"
date: 2008-10-11T22:00:00Z
tags:
  - .NET
  - Databases in general
  - Entity Framework
  - LINQ
  - Visual Studio
redirect_from: /id/228430
category: none
layout: post
---
<p>Well, generating EDMX file from database and letting Visual Studio to generate all the objects is easy. But sometimes you have your custom objects with custom logic. How to solve this? In version 1 of Entity Framework this isn't easy. It's possible, but not easy. The good news is, that for version 2 there is huge amount of work on POCO (<u>P</u>lain <u>O</u>ld <u>C</u>LR <u>O</u>bjects) with persistence ignorance.</p>

<p>With current version you have, in general, two possible choices. The "easier” way is to derive from special object <code>EntityObject</code>. Anyway, this is probably what you don't want, because you're probably deriving from your own objects (and as we know multiple inheritance isn't possible in C#). The other way is to implement some interfaces. It's not so straightforward, but, at least in my opinion, more practical.</p>

<p>In our simple example we'll be neither using complex types (it's not so hard to add it) nor any associations (I'll cover this later in other article). Let's start with our class, I'll call it Product and it'll be very simple.</p>

<pre class="brush:csharp">
public class Product
{
  private int _id;
  private string _name;
  private int _price;

  public int ID
  {
    get { return _id; }
    set { _id = value; }
  }

  public string Name
  {
    get { return _name; }
    set { _name = value; }
  }

  public int Price
  {
    get { return _price; }
    set { _price = value; }
  }
}
</pre>

<p>As you can see, the class is really simple. You can imagine some logic i.e. on price or on name length. To make this object "tasty” for Entity Framework infrastructure you have to implement only one interface. It's called <code>IEntityWithChangeTracker</code>. For associations support you should implement also <code>IEntityWithRelationships</code>. There's also <code>IEntityWithKey</code> interface that forces you to implement <code>EntityKey</code> to improve performance and decrease memory usage. It's just cherry on a pie.</p>

<p>The first noted interface implementation is pretty easy. You'll just implement one method in easy way.</p>

<pre class="brush:csharp">
void IEntityWithChangeTracker.SetChangeTracker(IEntityChangeTracker changeTracker)
{
  _changeTracker = changeTracker;
}
</pre>

<p>With complex types you have also set change tracker for these using <code>SetComplexChangeTracker</code> method.</p>

<p>To make change tracker working, we need to slightly change our setters. The setters should look like this for <code>Name</code> property.</p>

<pre class="brush:csharp">
set
{
  if (_changeTracker != null)
    _changeTracker.EntityMemberChanging("Name");

  _name = value;

  if (_changeTracker != null)
    _changeTracker.EntityMemberChanged("Name");
}
</pre>

<p>Pretty simple, isn't it? The last thing you have to change in your class is to add <code>EdmScalarProperty</code> attribute to <code>ID</code>, <code>Name</code> and <code>Price</code> members. That's all you have to do with the class.</p>

<p>Now comes the tricky part (don't be scared it's not heavy magic :-)). First you need to get SSDL, MSL and CSDL files. These files contain store-schema, mapping and conceptual-schema definition. Although you can write these files by hand, using some tool is much faster. The easiest way is to generate these using EdmGen (or maybe <a href="{{ site.url }}{% post_url 2008-07-08-227892-edmgen-on-steroids-edmgen2 %}">EdmGen2</a>). EdmGen is standard part of Entity Framework. Just use <code>FullGeneration</code> mode and provide <code>/connectionstring</code> and <code>/project</code> parameters. This gives you five files in result. Delete the two with <code>*.cs</code> extension, you don't need it. With EdmGen you get complete mapping for whole database so you have to delete some unnecessary stuff. Leave there only lines related to <code>Products</code> table (or whatever your table named is). If you don't understand content of these files, the best way is to generate <code>*.edmx</code> file in Visual Studio only for our table and look at the result <small>(EDMX file is in fact just CSDL, MSL and SSDL together plus some other stuff. You can use i.e. EdmGen2 to extract these files. But EdmGen2 isn't standard part of Entity Framework.)</small> right-clicking on the file and choosing <code>Open With...</code> and <code>XML Editor</code>. After this tricky part add these files to your project. On CSDL file open <code>Properties</code> and use for <code>Custom Tool</code> <code>EntityModelCodeGenerator</code>. This generates you new file under CSDL file. Copy content into new file and remove the <code>Custom Tool</code> definition. This new file contains implementation of <code>ObjectContext</code> class and also <code>Products</code> class. You can delete <code>Products</code> class (or class for your table), because we have ours. The last step is to replace occurrences of <code>Products</code> that has been removed, by <code>Product</code>, which is our class <small>(you can use Products (plural), where it makes sense, of course)</small>. So the result can look like this.</p>

<pre class="brush:csharp">
public global::System.Data.Objects.ObjectQuery&lt;Product&gt; Products
{
  get
  {
    if ((this._Products == null))
    {
      this._Products = base.CreateQuery&lt;Product&gt;("[Product]");
    }
    return this._Products;
  }
}

private global::System.Data.Objects.ObjectQuery&lt;Product&gt; _Products;

public void AddToProducts(Product product)
{
  base.AddObject("Product", product);
}
</pre>

<p>You can also change the first constructor, if you're interested.</p>

<p>After this you can use standard ways to query or update the <code>Products</code> table. You have to provide "entity frameworkish” connection string to make it work. The first option is to embed CSDL, MSL and SSDL files into resources and use <code>res://&lt;assemblyFullName&gt;/&lt;resourceName&gt;</code> specification in connection string (more info on <a href="http://msdn.microsoft.com/en-us/library/cc716756.aspx">http://msdn.microsoft.com/en-us/library/cc716756.aspx</a>) or simply copy these three files into some folder and use path. My choice was the second (copying files into same folder as executable), so my code looks like (using MS SQL Express):</p>

<pre class="brush:csharp">
CustomClasses_EDMContext ctx = new CustomClasses_EDMContext("metadata=CustomClasses_EDM.csdl|CustomClasses_EDM.ssdl|CustomClasses_EDM.msl;provider=System.Data.SqlClient;provider connection string="Data Source=.\sqlexpress;Initial Catalog=test;Integrated Security=True"");

var q = from p in ctx.Products
where p.ID &lt; 200
select p;

foreach (Product p in q)
{
  Console.WriteLine(p.Name);
  p.Name = p.Name + "R";
}

ctx.AddToProducts(new Product() { Name = "New Product", Price = 999 });

ctx.SaveChanges();
</pre>

<p>When you try to run this example, you'll be able not even to enumerate items in table (products), but also to update, add etc. it.</p>

<p>It's not as fast as using designer, you have to do some manual work (but I think you can write some tool to automate it and also EdmGen2 will help), however you're using your custom objects (without rewriting these completely).</p>

<p>The work on POCO and persistence ignorance in version 2 of Entity Framework will be a step forward, no doubts, but this isn't too bad isn't it? :-)</p>

<p>See also: <a href="{{ site.url }}{% post_url 2008-10-12-228431-how-to-use-custom-objects-with-associations-in-entity-framework %}">How to use custom objects with associations in Entity Framework</a></p>

<p><i>Published on <a href="http://dbsvet.cz/">Databazovy Svet</a></i></p>
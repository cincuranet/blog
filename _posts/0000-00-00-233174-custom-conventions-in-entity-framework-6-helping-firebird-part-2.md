---
title: |-
  Custom conventions in Entity Framework 6 helping Firebird - part 2
date: 2013-03-11T09:32:56Z
tags:
  - Entity Framework
  - Firebird
layout: post
---
> [Follow-up post.][9]

Few days ago I wrote a post "[Custom conventions in Entity Framework 6 helping Firebird][1]". [Arthur Vickers][2] from [Entity Framework][3] team had a good question whether it works also for columns and tables that are generated by Entity Framework (like join tables for M:N, FK columns (if not in model), etc.). And it actually does not. :) For this you have to dig a little bit deeper and use model-based convention. For this type of convention you have to write a class as there's (currently, alpha 3) no way to do it using fluent API in a lightweight way (and I would not expect this to change, this isn't common scenario).

<!-- excerpt -->

Anyway for properties to work you have to implement `IDbConvention<EdmProperty>` and for table `IDbConvention<EntityType>` (not `EntitySet`, you need to be able to see whether somebody set the table name already or not which for me is easier from `EntityType` type). Don't ask me how I found this. A lot of trial and error. And actually a lot of memories from around 2010 and Entity Framework v1 ([link][4], [link][5] (anybody here ever explored [MetadataProperties][6]?)) :).

```csharp
class FirebirdFriendlyModelConvention : IDbConvention<EdmProperty>, IDbConvention<EntityType>
{
	public void Apply(EdmProperty dbDataModelItem, EdmModel model)
	{
		var preferredName = (string)dbDataModelItem.Annotations.First(x => x.Name == "PreferredName").Value;
		if (preferredName == dbDataModelItem.Name)
			dbDataModelItem.Name = FirebirdNamingConvention.CreateName(dbDataModelItem.Name);
	}

	EntityType GetRootType(EntityType entityType)
	{
		if (entityType.BaseType != null)
			return GetRootType((EntityType)entityType.BaseType);
		return entityType;
	}

	string GetTableName(ICollection<DataModelAnnotation> anotations)
	{
		var anotation = anotations.FirstOrDefault(x => x.Name == "TableName");
		if (anotation == null)
			return null;
		return (string)anotation.Value;
	}

	public void Apply(EntityType dbDataModelItem, EdmModel model)
	{
		var entitySet = model.Containers.First().EntitySets.SingleOrDefault(e => e.ElementType == GetRootType(dbDataModelItem));
		var tableName = GetTableName(dbDataModelItem.Annotations);
		if (tableName == null)
		{
			tableName = FirebirdNamingConvention.CreateName(dbDataModelItem.Name);
			entitySet.GetType().GetProperty("Table").SetValue(entitySet, tableName);
		}
	}
}
```

As you can see it's not magic, if you know where to look at. Because the `Table` property is currently (alpha 3) not public I was forced to use reflection. [There's the related work item.][7]

With this conventions, hopefully, all the tables and columns, except specified explicitly, will be renamed to "common" [Firebird][8] naming.

[1]: {% include post_link id="233167" %}
[2]: http://blog.oneunicorn.com/
[3]: http://msdn.com/ef
[4]: {% include post_link id="230583" %}
[5]: {% include post_link id="231942" %}
[6]: http://msdn.microsoft.com/en-us/library/system.data.metadata.edm.metadataitem.metadataproperties.aspx
[7]: http://entityframework.codeplex.com/workitem/681
[8]: http://www.firebirdsql.org
[9]: {% include post_link id="233488" %}
---
title: "Try-Get functions one-liner"
date: 2014-04-24T12:38:00Z
tags:
  - .NET
  - C#
category: none
layout: post
---
<p>You know these Try-Get methods that return <code>bool</code> when the action was succesful and then in <code>out</code> parameter you have the actual result, right? Like <a href="http://msdn.microsoft.com/en-us/library/bb299639(v=vs.110).aspx"><code>IDictionary&lt;TKey, TValue&gt;.TryGetValue</code></a>. I hate these. You have to declare the <code>out</code> variable (I know C# 6 will simplify this), then have the <code>if</code>. Just too much noise. Today I had enough and I decided to solve it. In code. For me.</p> 
<!-- excerpt -->
<p>I knew I wanted something on "one line", without all the noise around. Also in case the Try-Get returns <code>false</code> I need to have some reasonable default value, preferably configurable. After maybe an hour of some prototyping I came with a solution that's pleasing for <i>my</i> eye and meets my quality ;) standards.</p>

<p>First I needed to somehow capture the Try-Get method, which has <code>out</code> parameter. That's not going to work directly with <a href="http://msdn.microsoft.com/en-us/library/bb534960(v=vs.110).aspx"><code>Func&lt;T&gt;</code></a>. Time for custom delegate. Ah. Haven't written these for months.</p>

<pre class="brush:csharp">
public delegate bool TryGetFunc&lt;TKey, TResult&gt;(TKey key, out TResult result);
</pre>

<p>Then I was playing with different shapes how to pass the Try-Get into my extension method. Obviously this is my personal preference and you might want to tweak it a little. The method itself is simple. It just does what you're doing manually - declare the <code>out</code>, <code>if</code>, return result or some default value depending on the <code>if</code>.</p>

<pre class="brush:csharp">
public static TResult TryGet&lt;T, TKey, TResult&gt;(this T @object, Func&lt;T, TryGetFunc&lt;TKey, TResult&gt;&gt; tryGet, TKey key, Func&lt;TResult&gt; defaultValue = null)
{
	var result = default(TResult);
	return tryGet(@object)(key, out result)
		? result
		: defaultValue != null ? defaultValue() : default(TResult);
}
</pre>

<p>You can then call it for example on a dictionary:</p>

<pre class="brush:csharp">
dictionary.TryGet(x =&gt; x.TryGetValue, key, () =&gt; "FooBar");
</pre>

<p>Which roughly corresponds to:</p>

<pre class="brush:csharp">
var result = default(string);
return dictionary.TryGetValue(key, out result)
	? result
	: "FooBar";
</pre>

<p>I know doesn't look like that much simplification. But if you're deep in some expression, one simple call makes you code flow much nicer (instead of "polluting" ;) it with variable etc.). Maybe I'll write similar helper for static methods like <a href="http://msdn.microsoft.com/en-us/library/f02979c7(v=vs.110).aspx"><code>int.TryParse</code></a>.</p>
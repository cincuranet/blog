---
title: "Nullable types - what's faster? - part 2"
date: 2013-09-23T12:07:00Z
tags:
  - .NET
category: none
layout: post
---
<p>Years ago I wrote post <a href="{{ site.url }}{% post_url 2008-10-20-228522-nullable-types-whats-faster %}">Nullable types - what's faster?</a> at that time on .NET FW 3.5. Today I came across post <a href="http://www.dotnetportal.cz/blogy/3/Tomas-Herceg/1965/Hratky-s-Nullable-typy">Hr√°tky s Nullable typy</a> which is related to my old post. That made me thinking about the test again and how it's the state today.</p>
<!-- excerpt -->
<p>So I redid the test. This time on .NET FW 4.5 and directly on Intel Core i7 on my laptop not in VPC. Again build with full optimizations turned on and debugger not attached. I also instead of using <code>short?</code> used <code>int?</code> because I think it's datatype that we, developers, use most often. I did couple of runs (about 100) removing some values that were obviously off and I also checked the generated IL, because that's pretty closely estimates what's actually going on.</p>

<p>1. <code>HasValue</code> vs. <code>!= null</code><br />
No difference in time (all times in a margin of error) and also the IL code is same.</p>

<p>2. <code>Foo.Value</code> vs. <code>(int)Foo</code><br />
No difference in time (all times in a margin of error) and also the IL code is same.</p>

<p>I don't know whether the C# 5.0 compiler now generates new (better) code or the old results were skewed because of some other influence (i.e. running on different machine (VPC actually)). But it probably doesn't matter. Important is the code is same and you don't have to think how to write it (although it's a micro-optimization, probably premature). Write what you like more. :)</p>

<p>If you have different results use comments and tell us (with some details about environment). </p>
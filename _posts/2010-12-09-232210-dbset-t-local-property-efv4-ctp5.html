---
title: "DbSet&lt;T&gt;.Local property (EFv4, CTP5)"
date: 2010-12-09T13:19:15Z
tags:
  - Entity Framework
redirect_from: /id/232210
category: none
layout: post
---
<p>Currently latest CTP for Entity Framework, <a href="http://www.microsoft.com/downloads/en/details.aspx?FamilyID=35adb688-f8a7-4d28-86b1-b6235385389d">CTP5</a>, contains one new property on DbSet&lt;T&gt;. It's called <code>Local</code> and it's very useful when you wanna work with objects you have already in memory. So it's good for queries without hitting the database, like databinding.</p>

<p>You can create layer that loads objects your application needs, or you think it might need. And then you use only <code>.Local</code> to access that data, still full LINQ support etc. This may help to lower number of queries you're sending to database. The property is of type ObservableCollection&lt;T&gt;, thus the databinding is super easy.</p>

<p>The method isn't something new. In fact it's exposing in a friendly was what's already possible - i.e. <a href="{{ site.url }}{% post_url 2010-07-26-231816-useful-find-method-on-dbset %}">Useful Find method on DbSet</a> and <a href="{{ site.url }}{% post_url 2009-02-22-229047-local-queries-2nd-edition %}">"Local" Queries 2nd edition</a>. It is using <a href="http://msdn.microsoft.com/en-us/library/system.data.objects.objectstatemanager.aspx">ObjectStateManager</a> to find all Unchanged, Added and Modified entities, exactly the ones you're probably interested in.</p>

<p>Let's see some example:</p>

<pre class="brush:csharp">
class Program
{
	static void Main(string[] args)
	{
		/*
		 * I have 3 rows in FOOBAR table in database.
		 */
		using (MyContext c = new MyContext())
		{
			// return's 2 rows and hits database
			var data1 = c.Set&lt;FooBar&gt;().OrderBy(x =&gt; x.ID).Take(2).ToArray();
			// return's 2 rows without hitting database
			var data2 = c.Set&lt;FooBar&gt;().Local.ToArray();
			// return's 1 row and hits database
			var data3 = c.Set&lt;FooBar&gt;().OrderBy(x =&gt; x.ID).Skip(2).Take(1).ToArray();
			// return's 3 rows without hitting database
			var data4 = c.Set&lt;FooBar&gt;().Local.ToArray();
		}
	}
}

class MyContext : DbContext
{
	public MyContext()
		: base(new FbConnection("database=localhost:rrr.fdb;user=sysdba;password=masterkey"), true)
	{ }

	protected override void OnModelCreating(System.Data.Entity.ModelConfiguration.ModelBuilder modelBuilder)
	{
		base.OnModelCreating(modelBuilder);

		modelBuilder.Entity&lt;FooBar&gt;().HasKey(x =&gt; x.ID);
		modelBuilder.Entity&lt;FooBar&gt;().Property(x =&gt; x.ID).HasColumnName("ID");
		modelBuilder.Entity&lt;FooBar&gt;().Property(x =&gt; x.Something).HasColumnName("S");
		modelBuilder.Entity&lt;FooBar&gt;().Map(m =&gt; m.ToTable("FOOBAR"));
	}
}

class FooBar
{
	public int ID { get; set; }
	public string Something { get; set; }
}
</pre>

<p>All important stuff about behavior is in comments. As you see, it acts as kind of local cache of objects, that are (mostly) reasonable to work with.</p>

<p>As always, nothing huge, but nice, handy.</p>

<p>PS: Did you noticed, I'm using <a href="http://www.firebirdsql.org/">Firebird</a>? ;)</p>
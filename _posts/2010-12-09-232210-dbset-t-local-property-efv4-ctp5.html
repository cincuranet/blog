---
title: "DbSet<T>.Local property (EFv4, CTP5)"
date: 2010-12-09T13:19:15Z
tags:
  - Entity Framework
category: devel
layout: post
---
Currently latest CTP for Entity Framework, <a href="http://www.microsoft.com/downloads/en/details.aspx?FamilyID=35adb688-f8a7-4d28-86b1-b6235385389d">CTP5</a>, contains one new property on DbSet&lt;T&gt;. It's called <code>Local</code> and it's very useful when you wanna work with objects you have already in memory. So it's good for queries without hitting the database, like databinding.

You can create layer that loads objects your application needs, or you think it might need. And then you use only <code>.Local</code> to access that data, still full LINQ support etc. This may help to lower number of queries you're sending to database. The property is of type ObservableCollection&lt;T&gt;, thus the databinding is super easy.

The method isn't something new. In fact it's exposing in a friendly was what's already possible - i.e. [intlink id=231816]Useful Find method on DbSet[/intlink] and <a href="{% post_url 2009-02-22-229047-local-queries-2nd-edition %}">"Local" Queries 2nd edition</a>. It is using <a href="http://msdn.microsoft.com/en-us/library/system.data.objects.objectstatemanager.aspx">ObjectStateManager</a> to find all Unchanged, Added and Modified entities, exactly the ones you're probably interested in.

Let's see some example:

<pre class="brush:csharp">
class Program
{
	static void Main(string[] args)
	{
		/* 
		 * I have 3 rows in FOOBAR table in database.
		 */
		using (MyContext c = new MyContext())
		{
			// return's 2 rows and hits database
			var data1 = c.Set&lt;FooBar&gt;().OrderBy(x =&gt; x.ID).Take(2).ToArray();
			// return's 2 rows without hitting database
			var data2 = c.Set&lt;FooBar&gt;().Local.ToArray();
			// return's 1 row and hits database
			var data3 = c.Set&lt;FooBar&gt;().OrderBy(x =&gt; x.ID).Skip(2).Take(1).ToArray();
			// return's 3 rows without hitting database
			var data4 = c.Set&lt;FooBar&gt;().Local.ToArray();
		}
	}
}

class MyContext : DbContext
{
	public MyContext()
		: base(new FbConnection("database=localhost:rrr.fdb;user=sysdba;password=masterkey"), true)
	{ }

	protected override void OnModelCreating(System.Data.Entity.ModelConfiguration.ModelBuilder modelBuilder)
	{
		base.OnModelCreating(modelBuilder);

		modelBuilder.Entity&lt;FooBar&gt;().HasKey(x =&gt; x.ID);
		modelBuilder.Entity&lt;FooBar&gt;().Property(x =&gt; x.ID).HasColumnName("ID");
		modelBuilder.Entity&lt;FooBar&gt;().Property(x =&gt; x.Something).HasColumnName("S");
		modelBuilder.Entity&lt;FooBar&gt;().Map(m =&gt; m.ToTable("FOOBAR"));
	}
}

class FooBar
{
	public int ID { get; set; }
	public string Something { get; set; }
}
</pre>

All important stuff about behavior is in comments. As you see, it acts as kind of local cache of objects, that are (mostly) reasonable to work with.

As always, nothing huge, but nice, handy.

PS: Did you noticed, I'm using <a href="http://www.firebirdsql.org/">Firebird</a>? ;)

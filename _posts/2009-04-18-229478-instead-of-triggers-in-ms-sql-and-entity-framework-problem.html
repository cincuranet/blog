---
title: "Instead of triggers in MS SQL and Entity Framework problem"
date: 2009-04-18T10:42:00Z
tags:
  - Entity Framework
  - MS SQL Server
category: none
layout: post
---
<p>I don't like the model of instead of and after triggers in MS SQL. The before and after ones are, in my opinion, better. Anyway I needed to do some complex tests, not possible with check constraints, before inserting. Hence I jumped into instead of trigger. No problem in a view. Or not? </p>
<p>The Entity Framework is smart enough to get all server generated columns back when inserting (or updating) â€“ see <a href="http://msdn.microsoft.com/en-us/library/bb738536.aspx" >StoreGeneratedPattern</a>. But the problem is how the identity column, often used for primary keys, is retrieved. The command issued after insert looks like (particular shape depends on other store generated columns and concurrency checks): <code>select &lt;PK column&gt; from &lt;some table&gt; where @@ROWCOUNT &gt; 0 and &lt;PK column&gt; = scope_identity()</code>.The problem is, that if you generate new PK value in trigger, it is different scope. Thus this command returns zero rows and EF will throw exception. </p>
<p>Hmm, this isn't the way. :( So one of the solutions is move away from instead of triggers and use stored procedures (remember that you need all three) and result binding (you <a class="" href="http://msdn.microsoft.com/en-us/library/cc716711.aspx" >might be forced</a> to create SPs (of fake ones in SSDL) for some related objects too). It's not easiest solution, but works nice and you don't have to introduce hacks etc.</p>
---
title: "TPH mapping discriminator condition from MetadataWorkspace"
date: 2010-08-25T14:07:19Z
tags:
  - Entity Framework
category: none
layout: post
---
<p>The <a href="http://msdn.microsoft.com/en-us/library/system.data.metadata.edm.metadataworkspace.aspx">MetadataWorkspace</a> contains a lot of <a href="{{ site.url }}{% post_url 2009-06-14-230583-metadataworkspace-in-entity-framework %}">useful information</a>. Recently I was facing a challenge to get information about TPH (<a href="http://msdn.microsoft.com/en-us/library/bb738443.aspx">table per hierarchy</a>) inheritance conditions for particular type. Sure, it's in EDMX file and/or in MSL file. So you can parse the XML and get the info. I was on the other hand more interested getting the info from MetadataWorkspace, partially as a good "brain training" 8) side project.</p>

<p>Sadly the information about the mapping is very limited. Most interesting parts are not public, thus you're forced to use <a href="http://en.wikipedia.org/wiki/Reflection_(computer_science)">reflection</a>. So it's a lot back and forth with, in my case, <a href="http://msdn.microsoft.com/en-us/library/cyzbs7s2.aspx">QuickWatch</a> window. It helps a little to be familiar with MSL file structure.</p>

<pre class="brush:csharp">
static object GetNonPublicPropertyValue(this object o, string propertyName)
{
	return o.GetType()
		.GetProperty(propertyName, BindingFlags.NonPublic | BindingFlags.Instance)
		.GetValue(o, null);
}

public static IEnumerable&lt;KeyValuePair&lt;string, object&gt;&gt; GetMappingConditions&lt;T&gt;(this ObjectContext context)
	where T : class
{
	string typeToSearch = typeof(T).Name;

	var mapping = context.MetadataWorkspace.GetItemCollection(DataSpace.CSSpace).First();

	return ((IEnumerable&lt;object&gt;)mapping.GetNonPublicPropertyValue("EntitySetMaps"))
		.SelectMany(entitySetMap =&gt; (IEnumerable&lt;object&gt;)entitySetMap.GetNonPublicPropertyValue("TypeMappings"))
		.Where(typeMapping =&gt;
			((IEnumerable&lt;dynamic&gt;)typeMapping.GetNonPublicPropertyValue("IsOfTypes")).Any(type =&gt; type.Name == typeToSearch)
			||
			((IEnumerable&lt;dynamic&gt;)typeMapping.GetNonPublicPropertyValue("Types")).Any(type =&gt; type.Name == typeToSearch))
		.SelectMany(typeMapping =&gt; (IEnumerable&lt;object&gt;)typeMapping.GetNonPublicPropertyValue("MappingFragments"))
		.SelectMany(mappingFragment =&gt; (IEnumerable&lt;object&gt;)mappingFragment.GetNonPublicPropertyValue("AllProperties"))
		.Where(mappingFragment =&gt; mappingFragment.GetType().Name == "StorageConditionPropertyMapping")
		.Select(condition =&gt;
			{
				bool? isNull = (bool?)condition.GetNonPublicPropertyValue("IsNull");
				string value = (string)condition.GetNonPublicPropertyValue("Value");
				return new KeyValuePair&lt;string, object&gt;((string)((dynamic)condition.GetNonPublicPropertyValue("ColumnProperty")).Name, (isNull.HasValue ? (object)isNull.Value : (object)value));
			});
}
</pre>

<p><small>Because the code is heavily using reflection and non public members, it's possible it'll not work other/future versions of Entity Framework. I tested it with current version, version 4.</small></p>

<p>It's written in a compact way. If you want to further dig into partial results, I recommend to split it into <code>foreach</code> loops and do small steps. That's in fact how I started and was incrementally discovering the information available at given level.</p>

<p>As all the data are not public, I'll not describe how and why it is as it is. I did it using trial and error process. :) Maybe there's other/simpler path. Feel free to use comments if you find one.</p>
---
title: "Count for System.Collections.Concurrent.ConcurrentStack&lt;T&gt;"
date: 2012-04-17T17:36:30Z
tags:
  - .NET
  - Best practice or not?
  - Multithreading/Parallelism/Asynchronous/Concurrency
category: none
layout: post
---
<p>Collections in <a href="http://msdn.microsoft.com/en-us/library/dd287108.aspx"><code>System.Collections.Concurrent</code></a> namespace are optimized for access from more (basically) threads. That means no stupid "one-lock-for-everything" approach. Actually these are <a href="http://en.wikipedia.org/wiki/Non-blocking_algorithm#Lock-freedom">lock free</a>.</p>

<p>It's good for performance, but also, if used foolhardily, the performance penalty can be too big. One example can be the <a href="http://msdn.microsoft.com/en-us/library/dd267331.aspx"><code>ConcurrentStack&lt;T&gt;</code> class</a>. As with a lot of collections, this stack also has a <a href="http://msdn.microsoft.com/en-us/library/dd287185.aspx"><code>Count</code> property</a>. But because it's a lock free implementation using <a href="http://en.wikipedia.org/wiki/Linked_list">linked list</a> the <code>Count</code> isn't that easy. Actually it's <i>O(n)</i> and this can be especially bad for big stacks. So use with care. As the remarks for this property recommends, if you need to know just whether it's empty of not, the <a href="http://msdn.microsoft.com/en-us/library/dd267246.aspx"><code>IsEmpty</code></a> is better (though realize, that in time you check it it might be empty, but not on next line where you're about to perform some action and vice versa).</p>

<p>Use the tools, but also know your tools.</p>

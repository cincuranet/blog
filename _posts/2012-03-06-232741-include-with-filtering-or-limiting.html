---
title: "Include with filtering or limiting"
date: 2012-03-06T08:22:09Z
tags:
  - Entity Framework
  - Expressions
  - LINQ
redirect_from: /id/232741
category: none
layout: post
---
<p>Almost four years ago I wrote an article <a href="{{ site.url }}{% post_url 2009-04-22-229660-load-with-filtering-or-limiting %}">Load with filtering or limiting</a>. You might want to do same stuff with <a href="http://msdn.microsoft.com/en-us/library/bb738708.aspx"><code>Include</code></a> method. It's not directly supported in this method but you can do it with anonymous object easily. There's only one catch, it's the anonymous object. That means, if you need the entities you need to manually select these out on <a href="http://msdn.microsoft.com/en-us/library/9eekhta0.aspx"><code>IEnumerable&lt;T&gt;</code></a> (doing it on query isn't going to work because <a href="http://msdn.microsoft.com/en-us/data/aa937723">Entity Framework</a> will (correctly) figure out you're not using the pieces of anonymous object and will change the generated query appropriately).</p>

<p>Small example:</p>
<pre class="brush:csharp">
context.EntitySet
	.Select(x =&gt; new { Entity = x, Related = x.Related.OrderBy(y =&gt; y.FooBar).Take(6) })
	.AsEnumerable()
	.Select(x =&gt; x.Entity)
	.ToArray();
</pre>

<p>Nothing fancy. But could it be wrapped inside method so you don't have to type it over and over again. In comments of <a href="{{ site.url }}{% post_url 2009-04-22-229660-load-with-filtering-or-limiting %}">above mentioned post</a> same question was raised. Well if I can write it manually, why it shouldn't be possible to extract it into method, right? Don't know whether this method has any real usage, but it was a nice exercise.</p>

<pre class="brush:csharp">
public static IEnumerable&lt;TMain&gt; Include2&lt;TMain, TOther&gt;(this IQueryable&lt;TMain&gt; source, Expression&lt;Func&lt;TMain, IEnumerable&lt;TOther&gt;&gt;&gt; path)
	where TMain : class
{
	TMain main = default(TMain);
	var dummy = new { Main = main, Included = Enumerable.Empty&lt;TOther&gt;() };
	Expression&lt;Func&lt;TMain, object&gt;&gt; exampleExpression = x =&gt; new
	{
		Main = x,
		Included = Enumerable.Empty&lt;TOther&gt;()
	};
	PropertyInfo mainProperty = dummy.GetType().GetProperty("Main");
	ParameterExpression accessParam = Expression.Parameter(dummy.GetType(), "x");
	Delegate mainBack = Expression.Lambda(Expression.MakeMemberAccess(accessParam, mainProperty), accessParam).Compile();

	NewExpression body = (exampleExpression.Body as NewExpression);
	Type anonymousType = body.Type;

	var parametersMap = exampleExpression.Parameters.Select((f, i) =&gt; new { f, s = path.Parameters[i] }).ToDictionary(p =&gt; p.s, p =&gt; p.f);
	Expression reboundBody = ParameterRebinder.ReplaceParameters(parametersMap, path.Body);
	NewExpression newExpression = body.Update(new[] { body.Arguments[0], reboundBody });
	LambdaExpression finalLambda = Expression.Lambda(newExpression, exampleExpression.Parameters);

	MethodInfo miA = typeof(Queryable).GetMethods()
		.Where(m =&gt; m.Name == "Select")
		.Where(m =&gt; m.GetParameters()[1].ParameterType.GetGenericArguments()[0].GetGenericArguments().Count() == 2)
		.First();
	MethodInfo miB = typeof(Enumerable).GetMethods()
		.Where(m =&gt; m.Name == "Select")
		.Where(m =&gt; m.GetParameters()[1].ParameterType.GetGenericArguments().Count() == 2)
		.First();

	MethodInfo selectAMethod = miA.MakeGenericMethod(typeof(TMain), anonymousType);
	var dataA = selectAMethod.Invoke(null, new object[] { source, finalLambda });

	MethodInfo selectBMethod = miB.MakeGenericMethod(anonymousType, typeof(TMain));
	var dataB = selectBMethod.Invoke(null, new object[] { dataA, mainBack });

	return dataB as IEnumerable&lt;TMain&gt;;
}
</pre>

<p>The method is doing little bit of magic with expressions and anonymous type to do what you would normally write by hand. It returns <a href="http://msdn.microsoft.com/en-us/library/9eekhta0.aspx"><code>IEnumerable&lt;T&gt;</code></a> because the object needs to be unwrapped locally so you can't add additional pieces into query. I'm using <code>ParameterRebinder</code> from <a href="http://blogs.msdn.com/b/meek/archive/2008/05/02/linq-to-entities-combining-predicates.aspx">Colin Meek's post</a> to properly rewire parameters. Same functionality can be also found in <a href="http://nuget.org/packages/Mono.Linq.Expressions">Mono.Linq.Expressions</a>.</p>

<p>From input parameters types (yeah, <i>the power of static typing [<a href="http://en.wikipedia.org/wiki/Anders_Hejlsberg">Anders Hejlsberg</a>]</i>) you can see how to use it:</p>

<pre class="brush:csharp">
context.EntitySet
	.Include2(x =&gt; x.Related.OrderBy(y =&gt; y.FooBar).Take(6))
	.ToArray();
</pre>

<p>That's all. 8-)</p>
---
title: "Running sync methods in async way"
date: 2009-01-17T13:00:00Z
tags:
  - .NET
  - Multithreading/Parallelism/Asynchronous/Concurrency
redirect_from: /id/228921
category: none
layout: post
---
<p>Probably you heard about the very good library called <a href="http://www.wintellect.com/PowerThreading.aspx" >Power Threading Library</a>. Shortly, it allows you to run async methods in a near-sync-looking code (and besides provides some useful classes for working in multithreaded environment). But the problem is, that you have to use methods ready for async way. That easy for dtabase calls or web service calls. But you may have your own code and you want to utilize this library to really burn up your CPU.</p>

<p>The obvious way is to define a delegate and use BeginInvoke/EndInvoke. However that's not what I was interested in. Thus I created some helper methods to use <i>any</i> method you have in async way with <a href="http://www.wintellect.com/PowerThreading.aspx" >Power Threading Library</a>. Interesting fact is that's also faster than using delegate (Jeffrey mentioned, more info <a href="http://blogs.msdn.com/cbrumme/archive/2003/07/14/51495.aspx" >here</a>).</p>
<pre class="brush:csharp">
using System;
using System.Threading;

using Wintellect.Threading.AsyncProgModel;

public class AsyncEnumeratorSyncHelper
{
    private AsyncEnumeratorSyncHelper()
    { }

    public static AsyncResult&lt;T&gt; BeginHelper&lt;T&gt;(AsyncCallback callback, object state, Func&lt;T&gt; method)
    {
        AsyncResult&lt;T&gt; ar = new AsyncResult&lt;T&gt;(callback, state);

        Action&lt;object&gt; work = (object asyncResult) =&gt; ExecuteHelper(method, (AsyncResult&lt;T&gt;)asyncResult);
        ThreadPool.QueueUserWorkItem(new WaitCallback(work), ar);

        return ar;
    }

    public static AsyncResult BeginHelper(AsyncCallback callback, object state, Action method)
    {
        // just dummy object
        return BeginHelper&lt;object&gt;(callback, state, () =&gt; { method(); return null; });
    }

    public static T EndHelper&lt;T&gt;(IAsyncResult asyncResult)
    {
        AsyncResult&lt;T&gt; ar = (AsyncResult&lt;T&gt;)asyncResult;

        return ar.EndInvoke();
    }

    public static void EndHelper(IAsyncResult asyncResult)
    {
        // just dummy object
        EndHelper&lt;object&gt;(asyncResult);
    }

    private static void ExecuteHelper&lt;T&gt;(Func&lt;T&gt; method, AsyncResult&lt;T&gt; asyncResult)
    {
        try
        {
            T result = method();
            asyncResult.SetAsCompleted(result, false);
        }
        catch (Exception ex)
        {
            asyncResult.SetAsCompleted(ex, false);
        }
    }
}
</pre>
<p>With this wrapper you can call any method in async way very easily.</p>

<p>Still you may notice, that it's expecting only methods without any input params. Although it looks like a problem, you can easily use lambdas to "push" params inside. If you have method <code>int Foo(string x)</code> you'll just create <code>() =&gt; Foo("rrr")</code>.</p>

<p>Feel free to post any problems or feedback here or in <a href="http://tech.groups.yahoo.com/group/PowerThreading/" >PowerThreading list</a>.</p>
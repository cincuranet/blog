---
title: "Memory mapped files in .NET 4"
date: 2009-10-18T13:42:52Z
tags:
  - .NET
  - C/C++
  - Delphi/Object Pascal/Pascal
  - Memory
category: none
layout: post
---
<p>Similarly to my way to <a href="{{ site.url }}{% post_url 2009-06-09-230550-countdownevent-class %}">CountdownEvent class</a>, I found <a href="http://msdn.microsoft.com/en-us/library/system.io.memorymappedfiles(VS.100).aspx">MemoryMappedFiles namespace</a>, which is new in .NET 4. It's in System.IO.</p>

<p>If you've done some work in stone ages in C/C++ or maybe ObjectPascal (Delphi) you may remember using these files. I used these for exchanging data between two applications, but the usage is pretty much endless. And now you can benefit from it in .NET directly, without using P/Invoke.</p>

<p>To see what's inside, I wrote two simple applications that are reading and writing some data (no synchronization ;)).</p>

<p>The first one is doing writing and reading:</p>
<pre class="brush:csharp">using (MemoryMappedFile mmf = MemoryMappedFile.CreateOrOpen("TestMemoryMappedFile", 1024 * 1024))
{
	using (MemoryMappedViewAccessor accessor = mmf.CreateViewAccessor())
	{
		HelperStuff.WriteData(accessor, 0);

		Console.ReadLine();

		HelperStuff.ReadData(accessor, 0);
	}
}</pre>
<p>and the second one is just reading:</p>
<pre class="brush:csharp">using (MemoryMappedFile mmf = MemoryMappedFile.CreateOrOpen("TestMemoryMappedFile", 1024 * 1024))
{
	using (MemoryMappedViewAccessor accessor = mmf.CreateViewAccessor())
	{
		HelperStuff.WriteData(accessor, 0);

		Console.ReadLine();

		HelperStuff.ReadData(accessor, 0);
	}
}</pre>
<p>Nothing magical. The reading and writing methods (placed in shared library) are simply creating some dummy data. In my case struct and string, saved as array of bytes.</p>
<pre class="brush:csharp">public static void ReadData(MemoryMappedViewAccessor accessor, int position)
{
	SomeData data1;

	accessor.Read&lt;SomeData&gt;(position, out data1);
	position += Marshal.SizeOf(typeof(SomeData));

	int length = accessor.ReadInt32(position);
	position += Marshal.SizeOf(typeof(int));

	byte[] data2 = new byte[length];

	accessor.ReadArray&lt;byte&gt;(position, data2, 0, data2.Length);

	Console.WriteLine(data1.CurrentDate);
	Console.WriteLine(Encoding.Unicode.GetString(data2));
}

public static void WriteData(MemoryMappedViewAccessor accessor, int position)
{
	SomeData data1 = new SomeData() { CurrentDate = DateTime.Today.Ticks };
	byte[] data2 = Encoding.Unicode.GetBytes(DateTime.Today.ToLongDateString());

	accessor.Write&lt;SomeData&gt;(position, ref data1);
	position += Marshal.SizeOf(typeof(SomeData));

	accessor.Write(position, data2.Length);
	position += Marshal.SizeOf(typeof(int));

	accessor.WriteArray&lt;byte&gt;(position, data2, 0, data2.Length);
}</pre>
<p>The struct is really dummy:</p>
<pre class="brush:csharp">public struct SomeData
{
	public long CurrentDate { get; set; }
}</pre>
<p>The reading and writing is little bit limited, as you're in fact dealing with just a bunch of memory, not some structured storage. But if you like working with it directly as stream (or you have some smart wrappers around streams), you can also use method <a href="http://msdn.microsoft.com/en-us/library/system.io.memorymappedfiles.memorymappedfile.createviewstream(VS.100).aspx">CreateViewStream</a> instead of <a href="http://msdn.microsoft.com/en-us/library/system.io.memorymappedfiles.memorymappedfile.createviewaccessor(VS.100).aspx">CreateViewAccessor</a> used in my example. These method have some overloads with option to specify also the access rights using <a href="http://msdn.microsoft.com/en-us/library/system.io.memorymappedfiles.memorymappedfileaccess(VS.100).aspx">MemoryMappedFileAccess</a>, so you can i.e. use CopyOnWrite and any write operations will not be seen by other processes.</p>

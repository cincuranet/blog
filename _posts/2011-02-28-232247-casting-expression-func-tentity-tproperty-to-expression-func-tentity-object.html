---
title: "Casting Expression<Func<TEntity, TProperty>> to Expression<Func<TEntity, object>>"
date: 2011-02-28T05:13:04Z
tags:
  - .NET
  - C#
category: devel
layout: post
---
<p>From time to time I'm dealing with API that's using Expression&lt;Func&lt;TEntity, object&gt;&gt; as parameter, mainly to show property you want to deal with. And that's fine, if you need just the expression itself. But I often create my custom extensions, where I'm somehow working with the property itself or the result. And that's a problem, because I don't know any info about the type, it's just object.</p>

<p>If you try to directly cast the expression, it will not work, of course. First I though, it's going to be a lot of juggle with pieces of expression and reconstructing the final one. But it's pretty easy, see yourself:</p>

<pre class="brush:csharp">
void FooBar&lt;TEntity, TProperty&gt;(TEntity entity, Expression&lt;Func&lt;TEntity, TProperty&gt;&gt; property)
{
	Expression&lt;Func&lt;TEntity, object&gt;&gt; result;
	if (typeof(TProperty).IsValueType)
		result =  Expression.Lambda&lt;Func&lt;TEntity, object&gt;&gt;(Expression.Convert(property.Body, typeof(object)), property.Parameters);
	else
		result = Expression.Lambda&lt;Func&lt;TEntity, object&gt;&gt;(property.Body, property.Parameters);
	// do something with result ...
}
</pre>

<p>I'm simply creating new expression based on the original ones' body and parameters. If the <code>TProperty</code>'s type was value type I only do boxing in addition.</p> 

<p>Nothing difficult, right?</p> 

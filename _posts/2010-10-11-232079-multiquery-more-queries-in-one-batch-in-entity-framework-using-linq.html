---
title: "MultiQuery (more queries in one batch) in Entity Framework using LINQ"
date: 2010-10-11T11:23:58Z
tags:
  - Entity Framework
  - LINQ
  - NHibernate
redirect_from: /id/232079/
category: none
layout: post
---
<p>I recently discovered nice feature of <a href="http://www.nhforge.org/">NHibernate</a>. It's called <a href="http://nhforge.org/doc/nh/en/index.html#performance-multi-query">MultiQuery</a> (but the name doesn't matter). The idea behind is simple. Instead of sending multiple queries one by one and melting performance of your application in network latency, send all in one batch.</p>

<p>I read couple of articles about it. Later something in my head started to working and I had an idea about trying to do it in <a href="http://msdn.microsoft.com/en-us/library/bb399572.aspx">Entity Framework</a>. :) I had a basic concept in my head in couple of minutes and I told myself I'll try to do it, but I'll not invest too much time into it. Just quick'n'dirty brain exercise for Saturday (alike <a href="http://community.bartdesmet.net/blogs/bart/Default.aspx">Bart de Smet</a>'s <a href="http://community.bartdesmet.net/blogs/bart/archive/tags/Crazy+Sundays/default.aspx">Crazy Sundays</a>).</p>

<p>The concept was simple. Record couple of <a href="http://msdn.microsoft.com/en-us/library/bb345303.aspx">ObjectQuery</a> objects, get commands out of these, create one huge batch, re-wire parameters (more about that later) and get results.</p>

<pre class="brush:csharp">
public class MultiQuery
{
	struct QueryRecord
	{
		public ObjectQuery Query { get; set; }
		public Type Type { get; set; }

		public static QueryRecord Create&lt;T&gt;(ObjectQuery&lt;T&gt; query)
		{
			return new QueryRecord() { Query = query, Type = typeof(T) };
		}
	}

	#region Fields
	ObjectContext _context;
	List&lt;QueryRecord&gt; _queries;
	#endregion

	#region Constructors
	public MultiQuery(ObjectContext context)
	{
		_queries = new List&lt;QueryRecord&gt;();

		_context = context;
	}
	#endregion

	#region Public Methods
	public MultiQuery Add&lt;T&gt;(ObjectQuery&lt;T&gt; query)
	{
		if (query == null)
			throw new ArgumentNullException("query");

		_queries.Add(QueryRecord.Create(query));

		return this;
	}

	public MultiQuery Add&lt;T&gt;(IQueryable&lt;T&gt; query)
	{
		return this.Add(query as ObjectQuery&lt;T&gt;);
	}

	public IEnumerable&lt;ObjectResult&gt; Execute()
	{
		IDbConnection storeConnection = ((EntityConnection)_context.Connection).StoreConnection;

		using (IDbCommand cmd = storeConnection.CreateCommand())
		{
			IDataParameterCollection parameters = cmd.Parameters;
			cmd.CommandText = CreateCommand(_queries.Select(q =&gt; q.Query), cmd.CreateParameter, ref parameters);

			bool shouldClose = (_context.Connection.State == ConnectionState.Closed);
			try
			{
				storeConnection.Open();
				using (IDataReader reader = cmd.ExecuteReader())
				{
					int cnt = 0;
					do
					{
						yield return _context.Translate(_queries[cnt].Type, reader);

						cnt++;
					} while (reader.NextResult());
				}
			}
			finally
			{
				if (shouldClose)
					storeConnection.Close();
			}
		}
	}
	#endregion

	#region Private Methods
	string CreateCommand(IEnumerable&lt;ObjectQuery&gt; queries, Func&lt;IDataParameter&gt; parameterCreator, ref IDataParameterCollection parameters)
	{
		List&lt;string&gt; commands = new List&lt;string&gt;();
		int cnt = 0;
		foreach (var q in _queries.Select(q =&gt; q.Query))
		{
			string query = q.ToTraceString();
			foreach (var p in q.Parameters)
			{
				IDataParameter parameter = parameterCreator();
				parameter.ParameterName = string.Format("@p{0}", cnt++);
				parameter.Value = p.Value;
				parameters.Add(parameter);

				// Not good. Better (and still easy) idea?
				query = query.Replace(string.Format("@{0}", p.Name), parameter.ParameterName);
			}
			commands.Add(query);
		}

		return string.Join(";" + Environment.NewLine, commands);
	}
	#endregion
}

static class MultiQueryExt
{
	internal static ObjectResult Translate(this ObjectContext context, Type type, IDataReader reader)
	{
		// ObjectResult&lt;TElement&gt; Translate&lt;TElement&gt;(DbDataReader reader)
		object result =
			context
			.GetType()
			.GetMethod("Translate", new[] { typeof(DbDataReader) })
			.MakeGenericMethod(type)
			.Invoke(context, new object[] { reader });
		return (ObjectResult)result;
	}
}
</pre>

<p>I'm here fully utilizing new <a href="{{ site.url }}{% post_url 2010-04-25-231337-new-translate-and-executestorequery-executestorecommand-on-objectcontext-in-entity-framework-v4 %}">Translate method</a> in Entity Framework 4 (for v1 similar method is available in <a href="http://code.msdn.microsoft.com/EFExtensions">EFExtensions</a>). The rest is done using pure <a href="http://msdn.microsoft.com/en-us/library/h43ks021.aspx">ADO.NET</a>. It's worth noting, that this code, same as in NHibernate, works only if the database and the underlying provider supports processing more queries in one command (i.e. <a href="http://www.microsoft.com/sqlserver/">Microsoft SQL Server</a> does, but <a href="http://www.firebirdsql.org">Firebird</a> does not).</p>

<p>Also small notice to parameters. I'm doing simple replace and that's dumb. It may fail and produce wrong results, but in very rare cases. So you should test thoroughly. The case when it produces wrong results is, when you write query in where you use <i>directly</i> (not as a variable etc.) string that is same as parameter name (i.e. <code>p__linq__&lt;number&gt;</code> for <a href="http://msdn.microsoft.com/en-us/library/system.data.sqlclient.aspx">SqlClient</a> or <code>p&lt;number&gt;</code> for <a href="http://www.firebirdsql.org/index.php?op=files&id=netprovider">FirebirdClient</a>). As you are in control of these strings you can change the code to use a variable, for instance.</p>

<p>A lot of "fetching" methods in Entity Framework supports also <a href="http://msdn.microsoft.com/en-us/library/system.data.objects.mergeoption.aspx">MergeOption</a>. Adding overload for <code>Execute</code> I'm leaving as exercise for readers. Likewise for the <a href="http://msdn.microsoft.com/en-us/library/bb387145.aspx">Entity SQL</a> queries.</p>
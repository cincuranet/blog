---
title: "Projection (select) on a collection running in parallel with exceptions handling"
date: 2010-08-04T15:20:52Z
tags:
  - .NET
  - LINQ
  - Multithreading/Parallelism/Asynchronous/Concurrency
category: devel
layout: post
---
Few days ago I posted an <a href="{% post_url 2010-08-02-231850-projection-select-on-a-collection-running-in-parallel %}">extension method to run projection on a collection in parallel</a>. The method has one problem. It's not dealing with exceptions. And because the ordering wasn't (and isn't) implicitly preserved, I did this small improvement.

Right now the method returns simple structure with original item, the result (if no exception occured, sure) and exception (if any). I didn't went to <a href="http://msdn.microsoft.com/en-us/library/system.aggregateexception.aspx">AggregateException</a> (although you can modify the code yourself to use it). Now you can decide while consuming what to do when exception occurred. Adding some kind of cancellation shouldn't be difficult.

The idea behind is the same as in <a href="{% post_url 2010-08-02-231850-projection-select-on-a-collection-running-in-parallel %}">previous version</a>.

<pre class="brush:csharp">
#region ParallelProjection
internal struct ParallelProjectionResult&lt;TSource, TResult&gt;
{
	public TSource Item { get; set; }
	public TResult Result { get; set; }
	public Exception Exception { get; set; }
}

internal static IEnumerable&lt;ParallelProjectionResult&lt;TSource, TResult&gt;&gt; ParallelProjection&lt;TSource, TResult&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, TResult&gt; projection, int maxParallelism)
{
	BlockingCollection&lt;ParallelProjectionResult&lt;TSource, TResult&gt;&gt; results = new BlockingCollection&lt;ParallelProjectionResult&lt;TSource, TResult&gt;&gt;();

	ThreadPool.QueueUserWorkItem((o) =&gt;
	{
		Semaphore semaphore = new Semaphore(maxParallelism, maxParallelism);
		CountdownEvent countdown = new CountdownEvent(1);
		try
		{
			foreach (var item in source)
			{
				countdown.AddCount();
				semaphore.WaitOne();
				ThreadPool.QueueUserWorkItem(
					(element) =&gt;
					{
						TSource e = (TSource)element;
						ParallelProjectionResult&lt;TSource, TResult&gt; result = new ParallelProjectionResult&lt;TSource, TResult&gt;();
						result.Item = e;
						try
						{
							result.Result = projection(e);
						}
						catch (Exception ex)
						{
							result.Exception = ex;
						}
						results.Add(result);
						semaphore.Release();
						countdown.Signal();
					},
					item);
			}
			countdown.Signal();
			countdown.Wait();
			results.CompleteAdding();
		}
		finally
		{
			if (countdown != null)
				countdown.Dispose();
			if (semaphore != null)
				semaphore.Dispose();
		}
	}, null);

	return results.GetConsumingEnumerable();
}
#endregion
</pre>

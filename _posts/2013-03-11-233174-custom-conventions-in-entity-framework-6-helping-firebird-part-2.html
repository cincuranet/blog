---
title: "Custom conventions in Entity Framework 6 helping Firebird - part 2"
date: 2013-03-11T09:32:56Z
tags:
  - Entity Framework
  - Firebird
category: none
layout: post
---
<p>Few days ago I wrote a post "<a href="{{ site.url }}{% post_url 2013-03-06-233167-custom-conventions-in-entity-framework-6-helping-firebird %}">Custom conventions in Entity Framework 6 helping Firebird</a>". <a href="http://blog.oneunicorn.com/">Arthur Vickers</a> from <a href="http://msdn.com/ef">Entity Framework</a> team had a good question whether it works also for columns and tables that are generated by Entity Framework (like join tables for M:N, FK columns (if not in model), etc.). And it actually does not. :) For this you have to dig a little bit deeper and use model-based convention. For this type of convention you have to write a class as there's (currently, alpha 3) no way to do it using fluent API in a lightweight way (and I would not expect this to change, this isn't common scenario).</p>
<!-- excerpt -->
<p>Anyway for properties to work you have to implement <code>IDbConvention&lt;EdmProperty&gt;</code> and for table <code>IDbConvention&lt;EntityType&gt;</code> (not <code>EntitySet</code>, you need to be able to see whether somebody set the table name already or not which for me is easier from <code>EntityType</code> type). Don't ask me how I found this. A lot of trial and error. And actually a lot of memories from around 2010 and Entity Framework v1 (<a href="{{ site.url }}{% post_url 2009-06-14-230583-metadataworkspace-in-entity-framework %}">link</a>, <a href="{{ site.url }}{% post_url 2010-08-25-231942-tph-mapping-discriminator-condition-from-metadataworkspace %}">link</a> (anybody here ever explored <a href="http://msdn.microsoft.com/en-us/library/system.data.metadata.edm.metadataitem.metadataproperties.aspx">MetadataProperties</a>?)) :).</p>

<pre class="brush:csharp">
class FirebirdFriendlyModelConvention : IDbConvention&lt;EdmProperty&gt;, IDbConvention&lt;EntityType&gt;
{
	public void Apply(EdmProperty dbDataModelItem, EdmModel model)
	{
		var preferredName = (string)dbDataModelItem.Annotations.First(x =&gt; x.Name == "PreferredName").Value;
		if (preferredName == dbDataModelItem.Name)
			dbDataModelItem.Name = FirebirdNamingConvention.CreateName(dbDataModelItem.Name);
	}

	EntityType GetRootType(EntityType entityType)
	{
		if (entityType.BaseType != null)
			return GetRootType((EntityType)entityType.BaseType);
		return entityType;
	}

	string GetTableName(ICollection&lt;DataModelAnnotation&gt; anotations)
	{
		var anotation = anotations.FirstOrDefault(x =&gt; x.Name == "TableName");
		if (anotation == null)
			return null;
		return (string)anotation.Value;
	}

	public void Apply(EntityType dbDataModelItem, EdmModel model)
	{
		var entitySet = model.Containers.First().EntitySets.SingleOrDefault(e =&gt; e.ElementType == GetRootType(dbDataModelItem));
		var tableName = GetTableName(dbDataModelItem.Annotations);
		if (tableName == null)
		{
			tableName = FirebirdNamingConvention.CreateName(dbDataModelItem.Name);
			entitySet.GetType().GetProperty("Table").SetValue(entitySet, tableName);
		}
	}
}
</pre>

<p>As you can see it's not magic, if you know where to look at. Because the <code>Table</code> property is currently (alpha 3) not public I was forced to use reflection. <a href="http://entityframework.codeplex.com/workitem/681">There's the related work item.</a></p>

<p>With this conventions, hopefully, all the tables and columns, except specified explicitly, will be renamed to "common" <a href="http://www.firebirdsql.org">Firebird</a> naming.</p>
